# Indexes Overview
---

{NOTE: }

* RavenDB uses __indexes__ to satisfy queries, allowing for fast query results.  
  The index type the query will use depends on the query itself.  
  Learn more about that in [queries always use an index](../../../client-api/session/querying/how-to-query#queries-always-provide-results-using-an-index).

* Indexes scan and process the entire dataset only once.  
  After the initial scan, an index will process only documents that were modified, added or deleted.

* Indexes are stored in a separate storage so that the raw data isn't affected.

* Indexes can be created:
  * From Studio  
  * From code - see [Creating and deploying indexes](../../../indexes/creating-and-deploying)  
  * Auto-indexes are generated by the server - see [Auto indexes](../../../indexes/creating-and-deploying#auto-indexes)  

* In this page:  
   * [Indexes - The General Concept](../../../studio/database/indexes/indexes-overview#indexes---the-general-concept)  
   * [Indexes - The Moving Parts](../../../studio/database/indexes/indexes-overview#indexes---the-moving-parts) : 
      * [Index Definition](../../../studio/database/indexes/indexes-overview#index-definition)  
      * [Indexing Process](../../../studio/database/indexes/indexes-overview#indexing-process)  
      * [Indexed Data](../../../studio/database/indexes/indexes-overview#indexed-data)  
   * [Index Types](../../../studio/database/indexes/indexes-overview#index-types) : 
      * [Auto Indexes -vs- Static Indexes](../../../studio/database/indexes/indexes-overview#auto-indexes--vs--static-indexes)  
      * [Map Indexes -vs- Map-Reduce Indexes](../../../studio/database/indexes/indexes-overview#map-indexes--vs--map-reduce-indexes)  
      * [Single-Collection Indexes -vs- Multi-Collection Indexes](../../../studio/database/indexes/indexes-overview#single-collection-indexes--vs--multi-collection-indexes)  
   * [Field Configuration Options](../../../studio/database/indexes/indexes-overview#field-configuration-options)
   * [Modifying Index Definition](../../../studio/database/indexes/indexes-overview#modifying-index-definition)
   * [Indexes in the Cluster](../../../studio/database/indexes/indexes-overview#indexes-in-the-cluster)
   * [Indexing Errors](../../../studio/database/indexes/indexes-overview#indexing-errors)
{NOTE/}

---

{PANEL: Indexes - The General Concept}

* Once defined, the index iterates over the documents,  
  and for every document-field that is requested to be indexed,  
  __a map is built__ between the terms derived from these fields and the actual documents that contain them.  

* A [query](../../../indexes/querying/query-index) operating on these fields ends up with a simple search  
  from the queried terms to the list of documents that contain them.  

* After the first **indexing** run, the index will keep this map current _without_ re-processing the entire dataset -  
  the index will only update the relevant indexed data when a document update happens in the database.

* Indexes in RavenDB are split across multiple axes (see more [below](../../../studio/database/indexes/indexes-overview#index-types))

  * Auto Indexes -vs- Static Indexes  
  * Map Indexes -vs- Map-Reduce Indexes  
  * Single-Collection Indexes -vs- Multi-Collection Indexes  
{PANEL/}

{PANEL: Indexes - The Moving Parts}

{NOTE: }

#### 1. Index Definition

* **The index definition** tells RavenDB how to index the data.  

* It specifies the fields to be indexed and how those fields should be indexed (i.e. allowing a full-text-search option).  
  These fields can be specified explicitly or defined dynamically supporting any document structure.  

* The index definition is created by the client (**Static-Index**), or by the server Query Optimizer(**Auto-Index**).  

* Note: Data from related documents can also be indexed using 'LoadDocument'.  
  Learn more in [Indexing Related Documents](../../../indexes/indexing-related-documents).  
{NOTE/}

{NOTE: }

#### 2. Indexing Process

* **Indexing** is the process of indexing the data, iterating over the documents, and creating a map  
  between the terms indexed and the actual documents that contain them.  

* Indexing is a background operation, it is scheduled to occur in an async manner upon any document change.  
  e.g. A document write operation doesn't wait for the index to complete processing -  
  The write operation is completed as soon as the transaction is written to disk.  

* An index is considered [Stale](../../../indexes/stale-indexes) if it had not yet processed all of the data.  

* A query can request that results are returned only when the index is up-to-date  
  by using method `WaitForNonStaleResults`.  
  A write operation can wait for the indexing process to finish before acknowledging the write  
  by using method `WaitForIndexesAfterSaveChanges`.  
  See: [Understanding Eventual Consistency](../../../users-issues/understanding-eventual-consistency).

* The async indexing process works with hard resets, shutdowns, and the like.  
  If the database was restarted _after_ a document was modified but _before_ it was indexed,  
  the indexing process will just pick up from where it left off and complete the work.  

* Each index is assigned a dedicated thread, thus no indexing process can interfere with any other.  
  By default, indexing threads start with a lower priority than request-processing threads.  
  The indexing-thread priority can be set higher and RavenDB will update this at the operating system level.  

* Indexing can be **throttled** to delay indexing tasks by a pre-set time period.  
  Throttling is helpful when sufficient server resources need to remain available 
  for users while heavy-duty indexing tasks are due.  
  See: [Index Throttling](../../../indexes/index-throttling)  

{NOTE/}

{NOTE: }

#### 3. Indexed Data

* The resulting output of 'step 2' (the indexing process) is also referred to as an Index.  
  Queries operate on **indexed data** to get documents result.  

* Note: The full document is _not_ stored in the index - only the document ID.  
  Upon a query match, we load the document itself from the document storage.  

* **Index Entry**  
  _Index-Entries_ are all of the document fields that are requested to be indexed, as defined in the index definition.  

* **Term**  
  The index-entries values are broken into _Terms_ according to the specified analyzer used in the index definition.  
  _Term_ is the actual indexed value that is stored in the index.  

* **Stored Data**  
  In addition to the _Terms_, some document [fields can be stored directly](../../../indexes/storing-data-in-index) in the index data.  
  This allows for query results to be fetched from the index itself instead of loading the original document.  
{NOTE/}
{PANEL/}

{PANEL: Index Types}

Indexes in RavenDB are split across the following multiple axes:

{NOTE: }

### Auto Indexes -vs- Static Indexes

* **Auto Indexes**:  
  * Auto-indexes are created by the server.  
  * When a query that has some filtering condition doesn't specify a specific index to be used,  
    the server Query Optimizer will first analyze the query and search for an already existing Auto-index that can answer the query.  
  * If there is no such index, the Query Optimizer creates on the fly an Auto-index that can answer this query and all previous queries on that collection.  
  * When the new Auto-index has caught up, RavenDB cleans up all the old Auto-indexes that are now superseded by the new one.

* **Static Indexes**:  
  * Static-indexes are created by the user (database admin only) from the Studio or from the [Client API](../../../indexes/creating-and-deploying).  
  * A Static-index can be used to make any computation on the document fields.  
    These computations run as a background process during indexing time, and not at query time.  
    This way the indexed data is ready for queries, providing fast query results when querying the index.  
  * The index shape (as defined in the index definition) and the shape of the source document don't have to be the same, 
    as the indexed data can be a computed value. 

{NOTE/}

{NOTE: }

### Map Indexes -vs- Map-Reduce Indexes

* **Map Indexes**:  
  [Map indexes](../../../studio/database/indexes/create-map-index) are simple indexes.  
  Contain one or more LINQ-based or JavaScript mapping functions indicating what should be indexed from the document, 
  and how it should be indexed, as these functions allow you to compute the indexed value.  

* **Map-Reduce Indexes**:  
  [Map-Reduce indexes](../../../studio/database/indexes/create-map-reduce-index) allow performing complex data aggregation.  
  The _Map_ stage is similar to a regular Map-Index, defining what data should be indexed.  
  The _Reduce_ stage operates on the Map results, specifying how the data should be grouped and aggregated.  
{NOTE/}

{NOTE: }

### Single-Collection Indexes -vs- Multi-Collection Indexes

* **Single-Collection Indexes**:  
  Index definition contains only one Map function defined on a specific collection.  

* **Multi-Collection Indexes**:  
  Data from several collections can be indexed (each in a different Map) and the results are united in a single index.  
  The only requirement is that all the Map definitions have the same output shape.  
{NOTE/}
{PANEL/}

{PANEL: Field Configuration Options}

Additional settings can be specified per field in the index-entry definition, configuring how the terms are indexed inside RavenDB. 
See [Create Map Index](../../../studio/database/indexes/create-map-index) to learn how to set these options in the Studio.  

* **Full-Text Search**  
  The original field data is split and tokenized according to the selected analyzer. Learn more about [analyzers here](../../../indexes/using-analyzers#full-text-search).  

  * Suggestions - Allow finding similar results 
    to the string in your query. i.e. Martin -> Martine.  
  * [Term Vector](../../../indexes/using-term-vectors) - Allow finding similar documents based on shared indexed terms.  

* **Spatial**  
  Allow geographical querying on longitude and latitude values or WKT values provided from the document.  
  Customize the spatial indexing strategy.  
  Learn more in [Indexing Spatial Data](../../../indexes/indexing-spatial-data)

* **Store Field**  
  Field can be stored within the indexed data.  
  This allows retrieving the value from the indexed data at query time, instead of loading the original document.  
  Learn more in [Storing Data in Index](../../../indexes/storing-data-in-index)
{PANEL/}

{PANEL: Modifying Index Definition}

* Only an index that is not set as 'Locked' can actually be modified.  

* When the index definition has changed in a way that invalidates the previous indexing results,  
  the modification is handled in a **side-by-side** manner.  
  e.g. A mapping function change will invalidate previous results, while a change in priority will not.  

* The original index is retained and is fully operable while the new index (with the new definition) is being built.  
  Once the new index is up-to-date the original index is removed in favor of the new one.  

* See the example in [Index List View - Side by Side](../../../studio/database/indexes/indexes-list-view#index-list-view---side-by-side-indexing).  
* RavenDB keeps a [history of index revisions](../../../studio/database/indexes/index-history), 
  allowing you to revert an index to any of its past revisions.  
  The number of index revisions kept can be configured in the 
  [Server Configuration Options](../../../server/configuration/configuration-options),  
  or using the [Database Settings view](../../../studio/database/indexes/index-history#view-and-update-number-of-index-revisions) in the Studio.
{PANEL/}

{PANEL: Indexes in the Cluster}

* Index & Auto-Index creation is a cluster operation. It goes through the [Raft protocol](../../../server/clustering/rachis/what-is-rachis#rachis---ravendbs-raft-implementation).  
  Index creation will fail if the majority of the nodes in the cluster are not reachable.  

* Once an index is created against any node in the [Database Group](../../../studio/database/settings/manage-database-group), 
  RavenDB will make sure that its definition is replicated to all the database's nodes. 
  The indexing process will occur separately on each node.  

* Note: The [External Replication](../../../studio/database/tasks/ongoing-tasks/external-replication-task) ongoing task does NOT replicate indexes.  

* In a multiple-nodes cluster, indexing can be configured to occur either in _Rolling deployment Mode_ 
  (one node at a time if machine resources are limited) 
  or in _Parallel mode_ (simultaneously on all nodes).  

{PANEL/}

{PANEL: Indexing Errors}

* An error in indexing a document means that this particular document is not indexed and you will not see it in the query result.  

* An index is only allowed a certain failure rate, above which it is marked in an error state.  
  An index in an error state cannot be queried and will return an immediate error.  

* See more in [Index List View - Errors](../../../studio/database/indexes/indexes-list-view#index-list-view---errors).  
{PANEL/}

## Related Articles

### Indexes
- [What are Indexes](../../../indexes/what-are-indexes)
- [Creating & Deploying Indexes](../../../indexes/creating-and-deploying)
- [Indexing Basics](../../../indexes/indexing-basics)

### Studio
- [Studio Index List View](../../../studio/database/indexes/indexes-list-view)  
- [Index History](../../../studio/database/indexes/index-history)

---

### Inside RavenDB 

- [Working with Indexes](https://ravendb.net/learn/inside-ravendb-book/reader/4.0/12-working-with-indexes)

---

### Code Walkthrough

- [Scroll to see various indexing guides](https://demo.ravendb.net/)
